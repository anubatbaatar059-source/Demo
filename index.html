<!doctype html>
<html lang="mn">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
  <title>WebAR ‚Äî Intro ‚Üí –ú–µ–Ω—é ‚Üí –î–∞—Å–≥–∞–ª (Final, no Zappar UI)</title>
  <style>
    :root { --z-ui:5; --z-menu:6; --z-debug:20 }
    html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,Arial,sans-serif}
    canvas.webgl{position:fixed;inset:0;width:100vw;height:100vh;background:#000}

    #tapToStart{position:fixed;inset:0;display:none;place-items:center;background:#000;z-index:var(--z-ui);cursor:pointer}
    .btn{padding:14px 18px;border:0;border-radius:14px;cursor:pointer;background:#fff;color:#111;font-weight:700;box-shadow:0 8px 28px rgba(0,0,0,.25)}

    #btnUnmute{position:fixed;left:50%;bottom:22px;transform:translateX(-50%);z-index:var(--z-ui);display:none}
    #menu{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:var(--z-menu)}
    .menu-inner{display:flex;flex-direction:column;gap:12px}

    #hint{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);z-index:var(--z-ui);
          color:#fff;background:rgba(0,0,0,.55);padding:10px 14px;border-radius:12px;display:none}

    #debug{position:fixed;left:10px;top:10px;z-index:var(--z-debug);color:#0f0;background:rgba(0,0,0,.5);
           padding:6px 8px;border-radius:6px;font:12px/1.25 monospace;white-space:pre-wrap;max-width:92vw}
  </style>

  <!-- THREE + Zappar -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js" defer></script>
  <script src="https://unpkg.com/@zappar/zappar-threejs@2.5.2/umd/zappar-threejs.js" defer></script>

  <script>
    // service worker –∫—ç—à –±—É–¥–ª–∏–∞–Ω–∞–∞—Å —Å—ç—Ä–≥–∏–π–ª—ç—Ö
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations?.().then(rs => rs.forEach(r => r.unregister()));
    }
    // –°–∞–Ω–≥—É—É–¥ –±“Ø—Ä—ç–Ω –∞—á–∞–∞–ª—Å–Ω—ã –¥–∞—Ä–∞–∞ resolve
    window.__depsReady = new Promise(res => addEventListener('load', () => {
      res({ THREE: window.THREE, ZapparThree: window.ZapparThree });
    }, { once:true }));
  </script>
</head>
<body>
  <div id="debug">DEBUG: booting‚Ä¶</div>

  <!-- Gesture fallback -->
  <div id="tapToStart"><button class="btn">‚ñ∂ –ö–∞–º–µ—Ä –Ω—ç—ç—Ö</button></div>

  <!-- UI -->
  <button id="btnUnmute" class="btn">üîä –î—É—É–≥ –∞—Å–∞–∞—Ö</button>
  <div id="menu"><div class="menu-inner">
    <button class="btn" id="btnExercise">–î–∞—Å–≥–∞–ª</button>
    <button class="btn" id="btnRestart">–ò–Ω—Ç—Ä–æ –¥–∞—Ö–∏–Ω</button>
  </div></div>
  <div id="hint">–ë–∞–π—Ä—à—É—É–ª–∞—Ö—ã–Ω —Ç—É–ª–¥ –¥—ç–ª–≥—ç—Ü—ç–Ω–¥ –Ω—ç–≥ —É–¥–∞–∞ —Ö“Ø—Ä</div>

  <!-- –ù—É—É—Ü–ª–∞–≥–¥—Å–∞–Ω –≤–∏–¥–µ–æ —ç–ª–µ–º–µ–Ω—Ç“Ø“Ø–¥ -->
  <video id="vidIntro" playsinline preload="auto" style="display:none" crossorigin="anonymous"></video>
  <video id="vidExercise" playsinline preload="auto" loop style="display:none" crossorigin="anonymous"></video>

<script>
/********** –¢–æ—Ö–∏—Ä–≥–æ–æ (–∑–∞–º–∞–∞ ”©”©—Ä–∏–π–Ω—Ö”©”© —Å–µ—Ä–≤–µ—Ä—Ç —Ç–∞–∞—Ä—É—É–ª) **********/
const INTRO_WEBM_URL     = "https://batbaatar-anu.github.io/my-ar-host/output_alpha_audio.webm";
const INTRO_MP4_URL      = ""; // iOS fallback (–∞–ª—å—Ñ–∞ –±–∞–π—Ö–≥“Ø–π –±–æ–ª —ç–Ω–¥ MP4 —Ö–∏–π–∂ –±–æ–ª–Ω–æ)
const EXERCISE_WEBM_URL  = "https://batbaatar-anu.github.io/my-ar-host/dasgal.webm";
const EXERCISE_MP4_URL   = "";

const dbg = (m)=>document.getElementById('debug').textContent = 'DEBUG: ' + m;

const vIntro   = document.getElementById('vidIntro');
const vEx      = document.getElementById('vidExercise');
const btnUnmute= document.getElementById('btnUnmute');
const menu     = document.getElementById('menu');
const hint     = document.getElementById('hint');
const tapLay   = document.getElementById('tapToStart');

/* ==== –í–∏–¥–µ–æ —ç—Ö “Ø“Ø—Å–≤—ç—Ä“Ø“Ø–¥–∏–π–≥ –∑”©–≤ (CORS) —Ç–∞–≤–∏—Ö + –∞–ª–¥–∞–∞ –ª–æ–≥–ª–æ—Ö ==== */
function setSources(el, webm, mp4=""){
  el.crossOrigin = "anonymous";
  el.setAttribute('playsinline', '');
  el.innerHTML = "";

  const canWebM = el.canPlayType?.('video/webm; codecs="vp8,opus"') || '';

  if (webm && canWebM) {
    const s1=document.createElement('source');
    s1.src=webm; s1.type='video/webm; codecs="vp8,opus"';
    el.appendChild(s1);
  }
  if (mp4) {
    const s2=document.createElement('source');
    s2.src=mp4; s2.type='video/mp4';
    el.appendChild(s2);
  }

  el.onerror = ()=>{
    const err = el.error;
    dbg('VIDEO ERROR: '+(err?.message || err?.code || 'unknown')+' url='+(el.currentSrc||'-'));
  };
  el.load();
}

/********** AR Engine **********/
let THREE, ZapparThree, renderer, camera, scene, tracker, anchor, plane;
let hasPlaced = false;
let texIntro, texEx, currentVideo;

let baseH = 0.9;                     // –º–µ—Ç—Ä ‚Äî –±–æ—Å–æ–æ ”©–Ω–¥”©—Ä
let scaleFactor = 1.2;               // preview –∞—Ä–∞–π —Ç–æ–º
const MIN_S = 0.3, MAX_S = 3;
let spinSpeed = 0.9*Math.PI/180;     // preview auto-spin

function applyScale(){ plane.scale.set(scaleFactor, scaleFactor, 1); plane.position.y=(baseH*scaleFactor)/2; }

async function ensureCamera() {
  // 1) –ë—Ä–∞—É–∑–µ—Ä —Ç–∞–ª–∞–∞—Å —à—É—É–¥ –∑”©–≤—à”©”©—Ä”©–ª –∞–≤–∞—Ö (Zappar UI –∞—à–∏–≥–ª–∞—Ö–≥“Ø–π)
  if (!navigator.mediaDevices?.getUserMedia) {
    throw new Error('Camera not supported');
  }
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal:'environment' }, width:{ideal:1280}, height:{ideal:720} },
      audio: false
    });
    // –∑”©–≤—Ö”©–Ω –∑”©–≤—à”©”©—Ä”©–ª –∞–≤–∞—Ö –∑–æ—Ä–∏–ª–≥–æ ‚Äî stream-—ç—ç ”©”©—Ä”©”© –Ω—ç—ç–¥—ç–≥ —Ç—É–ª —É–Ω—Ç—Ä–∞–∞—è
    stream.getTracks().forEach(t=>t.stop());
  } catch (e) {
    throw new Error('User denied camera or not available');
  }

  // 2) ZapparThree.Camera-–≥ –∞—Å–≥–∞–Ω–∞ (–∑”©–≤—à”©”©—Ä”©–ª –æ–ª–≥–æ–≥–¥—Å–æ–Ω —Ç—É–ª UI –≥–∞—Ä–∞—Ö–≥“Ø–π)
  try { camera.start(); } catch(e){}
  dbg('camera started (browser permission flow)');
}

function videoTexture(el){
  el.crossOrigin = "anonymous";
  const t = new THREE.VideoTexture(el);
  t.colorSpace = THREE.SRGBColorSpace;
  t.flipY = false;
  return t;
}

function fitPlaneToVideo(el){
  const w = el.videoWidth  || 1280;
  const h = el.videoHeight || 720;
  baseH = 0.9;
  const W = baseH * (w/h);
  plane.geometry.dispose();
  plane.geometry = new THREE.PlaneGeometry(W, baseH);
  applyScale();
}

// –ö–∞–º–µ—Ä—ã–Ω –∑”©–≤—Ö”©–Ω yaw-–≥ –¥–∞–≥—É—É–ª–∂ upright –±–∞—Ä–∏–Ω–∞
const _eul = new THREE.Euler(0,0,0,'YXZ');
function faceCameraYawOnly(){
  _eul.setFromQuaternion(camera.quaternion,'YXZ');
  _eul.x = 0; _eul.z = 0;
  plane.quaternion.setFromEuler(_eul);
}
function upright(){
  _eul.setFromQuaternion(plane.quaternion,'YXZ');
  _eul.x = 0; _eul.z = 0;
  plane.quaternion.setFromEuler(_eul);
}

// –ñ–µ—Å—Ç“Ø“Ø–¥ (–±–∞–π—Ä–ª—É—É–ª—Å–Ω—ã –¥–∞—Ä–∞–∞ –∏–¥—ç–≤—Ö—Ç—ç–π)
let pinch={active:false,startDist:0,startScale:1,startAngle:0,startYaw:0};
let drag ={active:false,startX:0,startYaw:0};
const dist2=(a,b)=>Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY);
const angle2=(a,b)=>Math.atan2(b.clientY-a.clientY,b.clientX-a.clientX);

addEventListener('touchstart', e=>{
  if (!hasPlaced) return;
  if (e.touches.length===2){
    pinch={active:true,startDist:dist2(e.touches[0],e.touches[1]),startScale:scaleFactor,startAngle:angle2(e.touches[0],e.touches[1]),startYaw:plane.rotation.y};
  } else if (e.touches.length===1){
    drag={active:true,startX:e.touches[0].clientX,startYaw:plane.rotation.y};
  }
},{passive:true});
addEventListener('touchmove', e=>{
  if (!hasPlaced) return;
  if (pinch.active && e.touches.length===2){
    const k = dist2(e.touches[0], e.touches[1])/(pinch.startDist||1);
    scaleFactor = Math.min(MAX_S, Math.max(MIN_S, pinch.startScale*k));
    const ang = angle2(e.touches[0], e.touches[1]);
    plane.rotation.y = pinch.startYaw + (ang - pinch.startAngle);
    upright(); applyScale();
  } else if (drag.active && e.touches.length===1){
    const dx = e.touches[0].clientX - drag.startX;
    plane.rotation.y = drag.startYaw + dx*0.004;
    upright();
  }
},{passive:true});
addEventListener('touchend', e=>{ if (e.touches.length<2) pinch.active=false; if (e.touches.length===0) drag.active=false; }, {passive:true});
addEventListener('wheel', e=>{ if (!hasPlaced) return; scaleFactor=Math.min(MAX_S,Math.max(MIN_S,scaleFactor*(e.deltaY>0?0.95:1.05))); applyScale(); }, {passive:true});
addEventListener('pointerdown', e=>{ if (!hasPlaced) return; drag={active:true,startX:e.clientX,startYaw:plane.rotation.y}; });
addEventListener('pointermove', e=>{ if (!hasPlaced||!drag.active) return; const dx=e.clientX-drag.startX; plane.rotation.y=drag.startYaw+dx*0.004; upright(); });
addEventListener('pointerup', ()=>{ drag.active=false; });

// ==== Bootstrap ====
(async function bootstrap(){
  ({ THREE, ZapparThree } = await window.__depsReady);
  if (!THREE || !ZapparThree) { dbg('libs not loaded'); return; }
  if (ZapparThree.browserIncompatible()) { ZapparThree.browserIncompatibleUI(); return; }

  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:'high-performance' });
  renderer.setSize(innerWidth, innerHeight);
  renderer.domElement.classList.add('webgl');
  document.body.appendChild(renderer.domElement);
  addEventListener('resize', ()=>renderer.setSize(innerWidth, innerHeight));

  // !!! GL context-–æ–æ –∑–∞–∞–≤–∞–ª –±“Ø—Ä—Ç–≥—ç–Ω—ç ‚Äî “Ø–≥“Ø–π –±–æ–ª —Ö–∞—Ä –¥—ç–ª–≥—ç—Ü –≥–∞—Ä—á –±–æ–ª–Ω–æ
  ZapparThree.glContextSet(renderer.getContext());

  // Camera + Scene
  camera = new ZapparThree.Camera({ userFacing:false });
  scene  = new THREE.Scene();
  scene.background = camera.backgroundTexture;

  // Tracker + Anchor
  tracker = new ZapparThree.InstantWorldTracker();
  anchor  = new ZapparThree.InstantWorldAnchorGroup(camera, tracker);
  scene.add(anchor);

  // Plane
  plane = new THREE.Mesh(
    new THREE.PlaneGeometry(1, 1),
    new THREE.MeshBasicMaterial({ transparent:true, side: THREE.DoubleSide })
  );
  anchor.add(plane);

  // Render loop
  renderer.setAnimationLoop(()=>{
    if (!hasPlaced){
      tracker.setAnchorPoseFromCameraOffset(0,0,-2); // preview: 2–º —É—Ä–¥
      faceCameraYawOnly();
      plane.rotation.y += spinSpeed;
    }
    camera.updateFrame(renderer);
    renderer.render(scene, camera);
  });

  // App visibility
  document.addEventListener('visibilitychange', ()=>{
    if (!document.hidden){ try{camera.start();}catch{} }
    else { try{camera.pause();}catch{} }
  });

  dbg('bootstrap ready ‚Üí auto-start');
  autoStart(); // —à—É—É–¥ —ç—Ö–ª“Ø“Ø–ª—ç—Ö –æ—Ä–æ–ª–¥–ª–æ–≥–æ
})();

// ===== Auto-start —É—Ä—Å–≥–∞–ª =====
async function autoStart(){
  try {
    // Permission (browser flow)
    await ensureCamera();

    // –í–∏–¥–µ–æ —ç—Ö “Ø“Ø—Å–≤—ç—Ä“Ø“Ø–¥
    setSources(vIntro, INTRO_WEBM_URL, INTRO_MP4_URL);
    setSources(vEx,    EXERCISE_WEBM_URL, EXERCISE_MP4_URL);

    // Textures
    texIntro = texIntro || videoTexture(vIntro);
    texEx    = texEx    || videoTexture(vEx);

    // –ò–Ω—Ç—Ä–æ preview-—ç—ç—Ä
    currentVideo = vIntro;
    plane.material.map = texIntro;
    hasPlaced = false;
    scaleFactor = 1.2; applyScale();

    if (vIntro.readyState >= 1) fitPlaneToVideo(vIntro);
    else vIntro.addEventListener('loadedmetadata', ()=>fitPlaneToVideo(vIntro), { once:true });

    // –ê–≤—Ç–æ —Ç–æ–≥–ª—É—É–ª–∞—Ö (–¥—É—É policy-–æ–æ—Å —Ö–∞–º–∞–∞—Ä—á unmute —Ç–æ–≤—á –≥–∞—Ä—á –º–∞–≥–∞–¥–≥“Ø–π)
    try { vIntro.muted=false; await vIntro.play(); btnUnmute.style.display='none'; }
    catch { vIntro.muted=true; vIntro.play().catch(()=>{}); btnUnmute.style.display='inline-block'; }

    // –ë–∞–π—Ä—à—É—É–ª–∞—Ö—ã–Ω —Ç—É–ª–¥ —ç—Ö–Ω–∏–π tap
    const place = ()=>{ hasPlaced=true; spinSpeed=0; removeEventListener('pointerdown', place); hint.style.display='none'; dbg('intro placed'); };
    addEventListener('pointerdown', place, { once:true, passive:true });
    hint.style.display='block';

    // –ò–Ω—Ç—Ä–æ –¥—É—É—Å–º–∞–≥—Ü –º–µ–Ω—é
    vIntro.onended = ()=>{ menu.style.display='flex'; hint.style.display='none'; dbg('intro ended ‚Üí menu'); };
  } catch (e) {
    // iOS —à–∏–≥ user-gesture —à–∞–∞—Ä–¥–≤–∞–ª
    tapLay.style.display = 'grid';
    dbg('need user gesture (tap to start) ‚Äî '+(e?.message||e));
  }
}

// Fallback overlay: –Ω—ç–≥ —É–¥–∞–∞–≥–∏–π–Ω tap ‚Üí —ç—Ö–ª“Ø“Ø–ª–Ω—ç
tapLay.addEventListener('pointerdown', async ()=>{
  tapLay.style.display='none';
  try{ await autoStart(); }catch(e){ dbg('after tap failed: '+(e?.message||e)); }
});

// Unmute
btnUnmute.addEventListener('click', async ()=>{
  try{ await currentVideo.play(); currentVideo.muted=false; btnUnmute.style.display='none'; } catch {}
});

// ‚Äû–î–∞—Å–≥–∞–ª‚Äú ‚Äî –∏–Ω—Ç—Ä–æ –¥—É—É—Å—Å–∞–Ω—ã –¥–∞—Ä–∞–∞
document.getElementById('btnExercise').addEventListener('click', async ()=>{
  menu.style.display = 'none';
  try {
    await ensureCamera();
    if (currentVideo) currentVideo.pause();
    currentVideo = vEx;
    plane.material.map = texEx;

    // —à–∏–Ω—ç –∫–æ–Ω—Ç–µ–Ω—Ç preview-—ç—ç—Ä
    hasPlaced = false;
    spinSpeed = 0.9 * Math.PI/180;
    scaleFactor = 1.2; applyScale();

    if (vEx.readyState >= 1) fitPlaneToVideo(vEx);
    else vEx.addEventListener('loadedmetadata', ()=>fitPlaneToVideo(vEx), { once:true });

    const place2 = async ()=>{
      hasPlaced = true; spinSpeed = 0;
      vEx.currentTime = 0;
      vEx.muted = false;
      try { await vEx.play(); btnUnmute.style.display='none'; }
      catch { vEx.muted=true; vEx.play().catch(()=>{}); btnUnmute.style.display='inline-block'; }
      removeEventListener('pointerdown', place2);
      hint.style.display='none';
      dbg('exercise placed & playing');
    };
    addEventListener('pointerdown', place2, { once:true, passive:true });
    hint.style.display='block';

    dbg('exercise ready (tap to place & play)');
  } catch (e) {
    tapLay.style.display = 'grid';
  }
});

// –ò–Ω—Ç—Ä–æ –¥–∞—Ö–∏–Ω
document.getElementById('btnRestart').addEventListener('click', async ()=>{
  menu.style.display='none';
  if (currentVideo) currentVideo.pause();
  currentVideo = vIntro;
  plane.material.map = texIntro;
  hasPlaced = false; spinSpeed = 0.9*Math.PI/180; scaleFactor=1.2; applyScale();
  if (vIntro.readyState >= 1) fitPlaneToVideo(vIntro);
  else vIntro.addEventListener('loadedmetadata', ()=>fitPlaneToVideo(vIntro), { once:true });
  try { vIntro.muted=false; await vIntro.play(); btnUnmute.style.display='none'; }
  catch { vIntro.muted=true; vIntro.play().catch(()=>{}); btnUnmute.style.display='inline-block'; }
  const place=()=>{ hasPlaced=true; spinSpeed=0; removeEventListener('pointerdown', place); hint.style.display='none'; dbg('intro placed'); };
  addEventListener('pointerdown', place, {once:true, passive:true});
  hint.style.display='block';
});
</script>
</body>
</html>
