<!doctype html>
<html lang="mn">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
  <title>WebAR ‚Äî Intro ‚Üí –ú–µ–Ω—é ‚Üí –î–∞—Å–≥–∞–ª</title>

  <style>
    :root { --z-ui:5; --z-menu:6; --z-debug:20 }
    html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,Arial,sans-serif}
    canvas.webgl{position:fixed;inset:0;width:100vw;height:100vh;background:#000}

    #tapToStart{position:fixed;inset:0;display:none;place-items:center;z-index:var(--z-ui);background:#000;cursor:pointer}
    #tapToStart .btn{padding:14px 18px;border:0;border-radius:14px;background:#fff;color:#111;font-weight:700;box-shadow:0 8px 28px rgba(0,0,0,.25)}

    #btnUnmute{position:fixed;left:50%;bottom:22px;transform:translateX(-50%);z-index:var(--z-ui);display:none}

    #menu{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:var(--z-menu)}
    .menu-inner{display:flex;flex-direction:column;gap:12px}
    .btn{padding:14px 18px;border:0;border-radius:14px;cursor:pointer;background:#fff;color:#111;font-weight:700;box-shadow:0 8px 28px rgba(0,0,0,.25)}

    #debug{position:fixed;left:10px;top:10px;z-index:var(--z-debug);color:#0f0;background:rgba(0,0,0,.5);
           padding:6px 8px;border-radius:6px;font:12px/1.2 monospace;white-space:pre-wrap;max-width:90vw}
  </style>

  <!-- THREE + Zappar -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js" defer></script>
  <script src="https://unpkg.com/@zappar/zappar-threejs@2.5.2/umd/zappar-threejs.js" defer></script>

  <script>
    // service worker –∫—ç—à –±—É–¥–ª–∏–∞–Ω–∞–∞—Å —Å—ç—Ä–≥–∏–π–ª—ç—Ö
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations?.().then(rs => rs.forEach(r => r.unregister()));
    }
    // –°–∞–Ω–≥—É—É–¥ –±“Ø—Ä—ç–Ω –∞—á–∞–∞–ª—Å–Ω—ã –¥–∞—Ä–∞–∞ resolve
    window.__depsReady = new Promise(res => addEventListener('load', () => {
      res({ THREE: window.THREE, ZapparThree: window.ZapparThree });
    }, { once:true }));
  </script>
</head>
<body>
  <div id="debug">DEBUG: booting‚Ä¶</div>

  <!-- Tap overlay (—ç—Ö–ª—ç—ç–¥ –ª —Ö–∞—Ä–∞–≥–¥–∞–Ω–∞) -->
  <div id="tapToStart"><button class="btn">‚ñ∂ –ö–∞–º–µ—Ä –Ω—ç—ç—Ö</button></div>

  <button id="btnUnmute" class="btn">üîä –î—É—É–≥ –∞—Å–∞–∞—Ö</button>
  <div id="menu"><div class="menu-inner">
    <button class="btn" id="btnExercise">–î–∞—Å–≥–∞–ª</button>
  </div></div>

  <!-- –ù—É—É—Ü–ª–∞–≥–¥—Å–∞–Ω <video> -->
  <video id="vidIntro" playsinline preload="auto" style="display:none"></video>
  <video id="vidExercise" playsinline preload="auto" loop style="display:none"></video>

  <script>
    /********** –¢–æ—Ö–∏—Ä–≥–æ–æ **********/
    const INTRO_WEBM_URL     = "https://batbaatar-anu.github.io/my-ar-host/output_alpha_audio.webm";
    const INTRO_MP4_URL      = "";
    const EXERCISE_WEBM_URL  = "https://batbaatar-anu.github.io/my-ar-host/dasgal.webm";
    const EXERCISE_MP4_URL   = "";

    const dbg = (m)=>document.getElementById('debug').textContent = 'DEBUG: ' + m;

    const vIntro   = document.getElementById('vidIntro');
    const vEx      = document.getElementById('vidExercise');
    const btnUnmute= document.getElementById('btnUnmute');
    const menu     = document.getElementById('menu');
    const tapLay   = document.getElementById('tapToStart');

    function setSources(el, webm, mp4=""){
      el.crossOrigin = "anonymous";
      el.innerHTML = "";
      if (webm){ const s1=document.createElement('source'); s1.src=webm; s1.type='video/webm; codecs="vp8,opus"'; el.appendChild(s1); }
      if (mp4 ){ const s2=document.createElement('source'); s2.src=mp4 ; s2.type='video/mp4'; el.appendChild(s2); }
      el.load();
    }

    /********** AR Engine **********/
    let THREE, ZapparThree, renderer, camera, scene, tracker, anchor, plane;
    let hasPlaced = false;
    let texIntro, texEx, currentVideo;
    let cameraStarted = false;

    // —Ö—ç–º–∂—ç—ç/—ç—Ä–≥“Ø“Ø–ª—ç–ª—Ç
    let baseH = 0.9;               // –º
    let scaleFactor = 1.2;         // –≠–•–õ–≠–•–≠–î –¢–û–ú ‚Äî preview
    const MIN_S = 0.3, MAX_S = 3;
    let spinSpeed = 0.9 * Math.PI/180; // preview auto-spin

    function applyScale(){
      plane.scale.set(scaleFactor, scaleFactor, 1);
      plane.position.y = (baseH * scaleFactor) / 2; // –≥–∞–∑–∞—Ä—Ç —Ç—É–ª–≥–∞–Ω–∞
    }

    async function initCamera() {
      try {
        dbg('requesting camera permission...');
        
        // Zappar permission request
        const permissionGranted = await ZapparThree.permissionRequest();
        if (!permissionGranted) {
          throw new Error('Camera permission denied');
        }
        
        dbg('permission granted, starting camera...');
        
        // Start the camera
        await camera.start();
        cameraStarted = true;
        
        dbg('camera started successfully');
        return true;
      } catch (error) {
        dbg('camera init failed: ' + error.message);
        throw error;
      }
    }

    function videoTexture(el){
      const t = new THREE.VideoTexture(el);
      t.colorSpace = THREE.SRGBColorSpace;
      return t;
    }

    function fitPlaneToVideo(el){
      const w = el.videoWidth  || 1280;
      const h = el.videoHeight || 720;
      baseH = 0.9;
      const W = baseH * (w/h);
      plane.geometry.dispose();
      plane.geometry = new THREE.PlaneGeometry(W, baseH);
      applyScale();
    }

    // Upright / preview yaw-follow
    const _eul = new THREE.Euler(0,0,0,'YXZ');
    function faceCameraYawOnly(){
      _eul.setFromQuaternion(camera.quaternion,'YXZ');
      _eul.x = 0; _eul.z = 0;
      plane.quaternion.setFromEuler(_eul);
    }
    function upright(){
      _eul.setFromQuaternion(plane.quaternion,'YXZ');
      _eul.x = 0; _eul.z = 0;
      plane.quaternion.setFromEuler(_eul);
    }

    // –ñ–µ—Å—Ç“Ø“Ø–¥ (—Ç–æ–º—Ä—É—É–ª–∞—Ö/—ç—Ä–≥“Ø“Ø–ª—ç—Ö)
    let pinch = { active:false, startDist:0, startScale:1, startAngle:0, startYaw:0 };
    let drag  = { active:false, startX:0, startYaw:0 };
    function dist2(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }
    function angle2(a,b){ return Math.atan2(b.clientY-a.clientY, b.clientX-a.clientX); }

    addEventListener('touchstart', e=>{
      if (!hasPlaced) return;
      if (e.touches.length===2){
        pinch = {
          active:true,
          startDist: dist2(e.touches[0], e.touches[1]),
          startScale: scaleFactor,
          startAngle: angle2(e.touches[0], e.touches[1]),
          startYaw: plane.rotation.y
        };
      } else if (e.touches.length===1){
        drag = { active:true, startX:e.touches[0].clientX, startYaw:plane.rotation.y };
      }
    }, {passive:true});
    addEventListener('touchmove', e=>{
      if (!hasPlaced) return;
      if (pinch.active && e.touches.length===2){
        const k = dist2(e.touches[0], e.touches[1]) / (pinch.startDist || 1);
        scaleFactor = Math.min(MAX_S, Math.max(MIN_S, pinch.startScale * k));
        const ang = angle2(e.touches[0], e.touches[1]);
        plane.rotation.y = pinch.startYaw + (ang - pinch.startAngle);
        upright(); applyScale();
      } else if (drag.active && e.touches.length===1){
        const dx = e.touches[0].clientX - drag.startX;
        plane.rotation.y = drag.startYaw + dx * 0.004;
        upright();
      }
    }, {passive:true});
    addEventListener('touchend', e=>{
      if (e.touches.length<2) pinch.active=false;
      if (e.touches.length===0) drag.active=false;
    }, {passive:true});
    addEventListener('wheel', e=>{
      if (!hasPlaced) return;
      scaleFactor = Math.min(MAX_S, Math.max(MIN_S, scaleFactor * (e.deltaY>0? 0.95 : 1.05)));
      applyScale();
    }, {passive:true});
    addEventListener('pointerdown', e=>{
      if (!hasPlaced) return;
      drag = { active:true, startX:e.clientX, startYaw:plane.rotation.y };
    });
    addEventListener('pointermove', e=>{
      if (!hasPlaced || !drag.active) return;
      const dx = e.clientX - drag.startX;
      plane.rotation.y = drag.startYaw + dx * 0.004;
      upright();
    });
    addEventListener('pointerup', ()=>{ drag.active=false; });

    (async function bootstrap(){
      try {
        const { THREE: T, ZapparThree: Z } = await window.__depsReady;
        THREE = T; ZapparThree = Z;
        
        if (!THREE || !ZapparThree) { 
          dbg('libs not loaded'); 
          return; 
        }
        
        if (ZapparThree.browserIncompatible()) { 
          ZapparThree.browserIncompatibleUI(); 
          return; 
        }

        dbg('initializing AR engine...');

        // Renderer
        renderer = new THREE.WebGLRenderer({ 
          antialias: true, 
          alpha: false, 
          powerPreference: 'high-performance' 
        });
        renderer.setSize(innerWidth, innerHeight);
        renderer.domElement.classList.add('webgl');
        document.body.appendChild(renderer.domElement);
        
        addEventListener('resize', () => {
          renderer.setSize(innerWidth, innerHeight);
          camera?.updateFrame(renderer);
        });
        
        // Set GL context for Zappar
        ZapparThree.glContextSet(renderer.getContext());

        // Camera + Scene
        camera = new ZapparThree.Camera({ 
          userFacing: false,
          rearCameraSource: 'default'
        });
        
        scene = new THREE.Scene();
        scene.background = camera.backgroundTexture;

        // Tracker + Anchor
        tracker = new ZapparThree.InstantWorldTracker();
        anchor = new ZapparThree.InstantWorldAnchorGroup(camera, tracker);
        scene.add(anchor);

        // Plane
        plane = new THREE.Mesh(
          new THREE.PlaneGeometry(1, 1),
          new THREE.MeshBasicMaterial({ 
            transparent: true, 
            side: THREE.DoubleSide,
            alphaTest: 0.01
          })
        );
        plane.rotation.set(0, 0, 0);
        anchor.add(plane);

        // Render loop
        renderer.setAnimationLoop(() => {
          if (cameraStarted) {
            if (!hasPlaced) {
              // preview: 2–º —É—Ä–¥, —Ç”©–≤–¥, –∞–≤—Ç–æ–º–∞—Ç–∞–∞—Ä —ç—Ä–≥—ç–Ω—ç
              tracker.setAnchorPoseFromCameraOffset(0, 0, -2);
              faceCameraYawOnly();
              plane.rotation.y += spinSpeed;
            }
            camera.updateFrame(renderer);
          }
          renderer.render(scene, camera);
        });

        // App visibility
        document.addEventListener('visibilitychange', () => {
          if (!document.hidden && cameraStarted) { 
            try { camera.start(); } catch(e) { dbg('resume failed: ' + e.message); } 
          } else if (cameraStarted) { 
            try { camera.pause(); } catch(e) {} 
          }
        });

        dbg('AR engine ready. Starting camera...');
        
        // Auto-start camera immediately
        startAR();
        
      } catch (error) {
        dbg('bootstrap failed: ' + error.message);
      }
    })();

    // Start function with proper gesture handling
    async function startAR() {
      try {
        tapLay.style.display = 'none';
        
        dbg('starting AR experience...');
        
        // Initialize camera first
        await initCamera();
        
        // Setup video sources
        setSources(vIntro, INTRO_WEBM_URL, INTRO_MP4_URL);
        setSources(vEx, EXERCISE_WEBM_URL, EXERCISE_MP4_URL);

        // Create textures
        texIntro = videoTexture(vIntro);
        texEx = videoTexture(vEx);

        // Setup intro video
        currentVideo = vIntro;
        plane.material.map = texIntro;
        hasPlaced = false;
        scaleFactor = 1.2; 
        applyScale();

        if (vIntro.readyState >= 1) {
          fitPlaneToVideo(vIntro);
        } else {
          vIntro.addEventListener('loadedmetadata', () => fitPlaneToVideo(vIntro), { once: true });
        }

        // Try to play with sound, fallback to muted
        try {
          vIntro.muted = false;
          await vIntro.play();
          btnUnmute.style.display = 'none';
        } catch {
          vIntro.muted = true;
          try {
            await vIntro.play();
            btnUnmute.style.display = 'inline-block';
          } catch(e) {
            dbg('video play failed: ' + e.message);
          }
        }

        // First tap places the anchor
        const place = () => {
          hasPlaced = true; 
          spinSpeed = 0;
          dbg('intro placed in world');
        };
        addEventListener('pointerdown', place, { once: true, passive: true });

        // When intro ends, show menu
        vIntro.onended = () => { 
          menu.style.display = 'flex'; 
          dbg('intro ended ‚Üí menu shown'); 
        };
        
        dbg('intro video ready (tap to place)');
        
      } catch (error) {
        dbg('start failed: ' + error.message);
        // Show tap overlay only if permission/camera failed
        tapLay.style.display = 'grid';
      }
    }

    // Fallback: Only if auto-start failed, show tap to retry
    tapLay.addEventListener('pointerdown', startAR);

    // Unmute button
    btnUnmute.addEventListener('click', async () => {
      if (currentVideo) {
        try {
          currentVideo.muted = false;
          await currentVideo.play();
          btnUnmute.style.display = 'none';
        } catch(e) {
          dbg('unmute failed: ' + e.message);
        }
      }
    });

    // Exercise button
    document.getElementById('btnExercise').addEventListener('click', async () => {
      try {
        menu.style.display = 'none';
        
        if (!cameraStarted) {
          await initCamera();
        }
        
        // Stop current video
        if (currentVideo) {
          currentVideo.pause();
        }
        
        // Switch to exercise video
        currentVideo = vEx;
        plane.material.map = texEx;
        
        hasPlaced = false;
        spinSpeed = 0.9 * Math.PI/180;
        scaleFactor = 1.2; 
        applyScale();

        if (vEx.readyState >= 1) {
          fitPlaneToVideo(vEx);
        } else {
          vEx.addEventListener('loadedmetadata', () => fitPlaneToVideo(vEx), { once: true });
        }

        // Place and play exercise
        const place2 = () => {
          hasPlaced = true; 
          spinSpeed = 0;
          vEx.currentTime = 0; 
          vEx.muted = false; 
          vEx.play().catch(e => {
            vEx.muted = true;
            vEx.play().catch(() => {});
            btnUnmute.style.display = 'inline-block';
          });
          dbg('exercise placed & playing');
        };
        addEventListener('pointerdown', place2, { once: true, passive: true });

        dbg('exercise ready (tap to place & play)');
        
      } catch (error) {
        dbg('exercise failed: ' + error.message);
        tapLay.style.display = 'grid';
      }
    });
  </script>
</body>
</html>